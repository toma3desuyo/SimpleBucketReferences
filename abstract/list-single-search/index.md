---
title: リスト内の単一検索
description: 目標要素を一つ見つけるための探索手法
---

## 概要
単一検索はリスト内から条件に合う要素を 1 つ見つける操作である。見つかったら即座に終了し、該当が無ければ `null` や特別な値を返す。

## 手法
- **線形探索**: 先頭から順に調べる。小規模や未ソートのリスト向け。
- **二分探索**: ソート済みリストに適用し O(log n) で見つける。
- **インデックス構築**: 頻繁に検索するならハッシュや木構造のインデックスを別途管理する。

## 基本例
```pseudo
関数 見つける(リスト, 条件):
    for 要素 in リスト:
        もし 条件(要素) なら return 要素
    return null
```
- 条件を関数として渡すと柔軟に利用できる。

## 応用パターン
### 最良一致
```pseudo
最良 = null
for 要素 in リスト:
    もし 条件(要素) かつ 要素.スコア > 最良.スコア なら:
        最良 = 要素
return 最良
```
- 全走査しても 1 件だけ返す。スコアリングなどに使う。

### インデックス付き検索
```pseudo
インデックス = マップ()
for 要素 in リスト:
    インデックス.代入(要素.id, 要素)
return インデックス.取得(検索ID)
```
- 検索を高速化するためインデックスを構築する。更新と同期させることが課題。

## 注意点
1. **無駄な走査**: 見つけたら必ずループを抜ける。忘れると O(n) から O(n^2) になる可能性がある。
2. **比較の意味**: 何をもって一致とするかを関数に閉じ込め、比較ロジックが散在しないようにする。
3. **複数一致**: 最初の一致だけでよいのか、すべて集めるべきか要件を確認する。

## 関連トピック
- `abstract/list-membership/index.md`: 包含判定
- `abstract/list-traversal/index.md`: リスト走査
- `abstract/key-existence/index.md`: 連想配列の検索
