---
title: 例外処理
description: 実行時エラーを捕捉し回復するための仕組み
---

## 概要
例外処理は予期しないエラーを捕捉し、アプリケーション全体への影響を抑えるメカニズムである。`try`/`catch`/`finally` といった構文で提供され、リソース解放やユーザー通知を担う。

## 流れ
1. エラーが発生すると例外オブジェクトが生成され、スタックを巻き戻しながら捕捉ブロックを探索する。
2. 最初に一致するハンドラで例外が処理される。
3. `finally` ブロックは結果の成否に関わらず実行される。

## 基本例
```pseudo
try:
    接続 = 開く()
    データ = 接続.取得()
catch ネットワークエラー as e:
    ログ(e)
    再試行()
finally:
    もし 接続 が null でないなら 接続.閉じる()
```
- 例外型ごとに異なる処理を実装し、リソースを `finally` で確実に解放する。

## 応用パターン
### 再スロー
```pseudo
catch ドメインエラー as e:
    ログ(e)
    throw e
```
- 一部の情報を付与して上位に再スローする。

### 例外を値に変換
```pseudo
結果 = try:
    return 成功値
catch e:
    return { 状態: "失敗", 理由: e }
```
- 関数の戻り値として成功/失敗を表現し、呼び出し側で分岐できるようにする。

## 注意点
1. **過剰な捕捉**: すべての例外をまとめて握りつぶすと原因調査が困難。重要な例外は再スローする。
2. **コントロールフロー化**: 例外を通常の分岐代わりに使うと性能が低下し可読性も落ちる。例外は例外的ケースに限定する。
3. **非同期との連携**: 非同期タスクの例外は待機地点まで伝播しない。プロミスの失敗ハンドラなどで確実に捕捉する。

## 関連トピック
- `abstract/async-wait/index.md`: 非同期待機での例外
- `abstract/none-like-type/index.md`: エラーを値で返す代替策
- `abstract/encapsulation/index.md`: エラー境界の設計
