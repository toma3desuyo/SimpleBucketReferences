---
title: 反復処理
description: コレクションを順番に処理する制御構造
---

## 概要
反復処理は配列や連想配列などの要素を順番に取り出して処理する仕組みである。`for`、`while`、イテレーター API などで提供され、データ走査や集計の基本となる。

## 主なスタイル
- **カウント型ループ**: インデックスを増やしながら走査。範囲指定に適する。
- **イテレーター型**: `for 要素 in コレクション` のようにイテレーターを介して要素を取得する。
- **ストリーム処理**: map/filter/reduce のように宣言的に連結する。

## 基本例
```pseudo
for i = 0 から リスト.長さ まで:
    表示(リスト[i])

for 要素 in リスト:
    表示(要素)
```
- カウント型はインデックス操作が必要、イテレーター型はコレクション抽象に依存する。

## 応用パターン
### 早期終了
```pseudo
for 要素 in リスト:
    もし 要素 が 条件 を満たす なら:
        見つかった = 要素
        break
```
- 条件を満たしたらループを抜ける。`break` や `return` の挙動を決める。

### 並列反復
```pseudo
for 各チャンク in リスト.分割(サイズ: 100):
    並列実行(チャンク, 処理)
```
- 大量データを複数ワーカーで処理する場合、順序保証と排他制御を検討する。

## 注意点
1. **無限ループ**: 終了条件を確実に満たすように更新する。`while true` を使用する場合は `break` 条件を入れる。
2. **可変コレクション**: 反復中のコレクション変更が許されるか仕様を確認する。必要ならコピーを作る。
3. **コストの把握**: 反復内で重い処理を行うと全体が遅くなる。前処理やキャッシュを検討する。

## 関連トピック
- `abstract/iteration-flow-control/index.md`: ループ制御
- `abstract/list-traversal/index.md`: リスト走査
- `abstract/value-enumeration/index.md`: 値の列挙
