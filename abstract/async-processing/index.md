---
title: 非同期処理
description: 同期ブロックを避けて複数タスクを進める抽象モデル
---

## 概要
非同期処理は、待機が必要な操作（I/O、ネットワーク、タイマーなど）を他の処理と重ねて実行する手法である。タスクをスケジューラに登録し、完了時にコールバックやフューチャーで結果を受け取る。

## コア概念
- **イベントループ**: タスクキューからジョブを取り出し、完了通知を順番に処理する。
- **フューチャー/プロミス**: まだ計算が完了していない値を表現し、成功・失敗の状態遷移を管理する。
- **ノンブロッキング I/O**: 待機中にスレッドを塞がない API。CPU バウンド処理はワーカーへ回す。

## 基本フロー
```pseudo
操作1 = 非同期API.呼び出し(入力)
操作2 = 非同期API.呼び出し(別入力)

結合 = 操作1.完了後(無名関数(値1):
    return 操作2.完了後(無名関数(値2):
        return (値1, 値2)
    )
)
```
- 依存関係がある場合はチェーンさせる。
- 依存が無い場合は `並列待機([操作1, 操作2])` のように一括待機する。

## 応用パターン
### タイムアウト制御
```pseudo
結果 = 最初に完了したもの(
    実処理,
    タイマー.開始(期間: 500ms)
)
```
- 期限超過時はフォールバック結果を返すか、再試行キューに登録する。

### バッチ化
```pseudo
バッファに追加(要求)
もし バッファ.サイズ >= 50 または 時間経過 >= 100ms:
    まとめて送信(バッファ)
    バッファをクリア
```
- 高頻度の非同期要求をまとめることでスループットを改善する。

## 注意点
1. **競合状態**: 複数タスクが同じリソースを触る場合、排他制御やロックフリー構造が必要。
2. **エラーハンドリング**: 失敗が別スレッドで発生するため、必ず成功・失敗の両パスを接続しないと例外が未処理になる。
3. **文脈の喪失**: ログやトレース ID を継承しないと調査が困難になる。コンテキスト伝播の仕組みを設計する。

## 関連トピック
- `abstract/async-wait/index.md`: 非同期完了待機のパターン
- `abstract/callback-function/index.md`: コールバック設計
- `abstract/external-communication/index.md`: ネットワーク I/O と非同期化
